From 8d1b379f8baa959603ae425ffe870fa46e4d3ea2 Mon Sep 17 00:00:00 2001
From: Kyrie112 <895487344@qq.com>
Date: Sat, 11 Oct 2025 09:14:17 +0000
Subject: [PATCH] Add explain statement to AST.

---
 minigu/core/src/session.rs                    | 42 ++++++++++++++++---
 minigu/gql/parser/src/ast/procedure_spec.rs   |  6 +++
 minigu/gql/parser/src/lexer.rs                |  2 +
 .../parser/src/parser/impls/procedure_spec.rs | 10 +++++
 .../gql/planner/src/binder/procedure_spec.rs  |  8 +++-
 .../gql/planner/src/bound/procedure_spec.rs   |  6 +++
 minigu/gql/planner/src/lib.rs                 |  5 ++-
 .../src/logical_planner/procedure_spec.rs     |  4 ++
 8 files changed, 76 insertions(+), 7 deletions(-)

diff --git a/minigu/core/src/session.rs b/minigu/core/src/session.rs
index 1079935..034e287 100644
--- a/minigu/core/src/session.rs
+++ b/minigu/core/src/session.rs
@@ -81,24 +81,32 @@ fn handle_transaction_activity(&self, activity: &TransactionActivity) -> Result<
         let result = activity
             .procedure
             .as_ref()
-            .map(|procedure| self.handle_procedure(procedure.value()))
+            .map(|procedure| {
+                let proc = procedure.value();
+                let is_explain = matches!(proc.statement.value(), gql_parser::ast::Statement::Explain(_));
+                self.handle_procedure(proc, is_explain)
+            })
             .transpose()?
             .unwrap_or_default();
         Ok(result)
     }
 
-    fn handle_procedure(&self, procedure: &Procedure) -> Result<QueryResult> {
+    fn handle_procedure(&self, procedure: &Procedure, is_explain: bool) -> Result<QueryResult> {
         let mut metrics = QueryMetrics::default();
 
         let start = Instant::now();
         let planner = Planner::new(self.context.clone());
-        let physical_plan = planner.plan_query(procedure)?;
+        let plan = planner.plan_query(procedure, is_explain)?;
         metrics.planning_time = start.elapsed();
 
-        let schema = physical_plan.schema().cloned();
+        if is_explain {
+            return self.format_explain(plan);
+        }
+
+        let schema = plan.schema().cloned();
         let start = Instant::now();
         let chunks: Vec<_> = self.context.database().runtime().scope(|_| {
-            let mut executor = ExecutorBuilder::new(self.context.clone()).build(&physical_plan);
+            let mut executor = ExecutorBuilder::new(self.context.clone()).build(&plan);
             executor.into_iter().try_collect()
         })?;
         metrics.execution_time = start.elapsed();
@@ -109,4 +117,28 @@ fn handle_procedure(&self, procedure: &Procedure) -> Result<QueryResult> {
             chunks,
         })
     }
+
+    fn format_explain(&self, plan: impl PlanData) -> Result<QueryResult> {
+        let mut output = String::new();
+        self.format_explain_output(&plan, &mut output, 0);
+
+        let schema = Some(Arc::new(DataSchema::new(vec![DataField::new(
+            "EXPLAIN".to_string(),
+            LogicalType::String,
+            false
+        )])));
+
+        let chunks = vec![DataChunk::new(
+            vec![Arc::new(arrow::array::StringArray::from(vec![output]))]
+        )];
+        Ok(QueryResult {
+            schema,
+            metrics: QueryMetrics::default(),
+            chunks,
+        })
+    }
+
+    fn format_explain_output(& self, plan: &impl PlanData, output: &mut String, indent: usize) {
+        // todo: format logical plan output
+    }
 }
diff --git a/minigu/gql/parser/src/ast/procedure_spec.rs b/minigu/gql/parser/src/ast/procedure_spec.rs
index 4defb46..8068db8 100644
--- a/minigu/gql/parser/src/ast/procedure_spec.rs
+++ b/minigu/gql/parser/src/ast/procedure_spec.rs
@@ -16,11 +16,17 @@ pub struct Procedure {
     pub next_statements: VecSpanned<NextStatement>,
 }
 
+#[apply(base)]
+pub struct ExplainStatement {
+    pub statement: Box<Spanned<Statement>>,
+}
+
 #[apply(base)]
 pub enum Statement {
     Catalog(LinearCatalogModifyingStatement),
     Query(CompositeQueryStatement),
     Data(LinearDataModifyingStatement),
+    Explain(ExplainStatement),
 }
 
 #[apply(base)]
diff --git a/minigu/gql/parser/src/lexer.rs b/minigu/gql/parser/src/lexer.rs
index 8d61dc5..f45c38e 100644
--- a/minigu/gql/parser/src/lexer.rs
+++ b/minigu/gql/parser/src/lexer.rs
@@ -156,6 +156,8 @@ pub enum TokenKind<'a> {
     Exists,
     #[token("exp", ignore(case))]
     Exp,
+    #[token("explain", ignore(case))]
+    Explain,
     #[token("false", ignore(case))]
     False,
     #[token("filter", ignore(case))]
diff --git a/minigu/gql/parser/src/parser/impls/procedure_spec.rs b/minigu/gql/parser/src/parser/impls/procedure_spec.rs
index b4ba15e..5377aa2 100644
--- a/minigu/gql/parser/src/parser/impls/procedure_spec.rs
+++ b/minigu/gql/parser/src/parser/impls/procedure_spec.rs
@@ -72,10 +72,20 @@ pub fn statement(input: &mut TokenStream) -> ModalResult<Spanned<Statement>> {
             .map(Statement::Catalog)
             .spanned(),
         linear_data_modifying_statement.map_inner(Statement::Data),
+        explain_statement.map_inner(Statement::Explain),
     ))
     .parse_next(input)
 }
 
+pub fn explain_statement(input: &mut TokenStream) -> ModalResult<Spanned<ExplainStatement>> {
+    seq! {ExplainStatement{
+        _: TokenKind::Explain,
+        statement: statement.map(Box::new),
+    }}
+    .spanned()
+    .parse_next(input)
+}
+
 pub fn next_statement(input: &mut TokenStream) -> ModalResult<Spanned<NextStatement>> {
     seq! {NextStatement{
         _: TokenKind::Next,
diff --git a/minigu/gql/planner/src/binder/procedure_spec.rs b/minigu/gql/planner/src/binder/procedure_spec.rs
index f161cc9..3248c56 100644
--- a/minigu/gql/planner/src/binder/procedure_spec.rs
+++ b/minigu/gql/planner/src/binder/procedure_spec.rs
@@ -4,7 +4,7 @@
 
 use super::Binder;
 use super::error::BindResult;
-use crate::bound::{BoundProcedure, BoundStatement};
+use crate::bound::{BoundProcedure, BoundStatement, BoundExplainStatement};
 
 impl Binder<'_> {
     pub fn bind_procedure(&mut self, procedure: &Procedure) -> BindResult<BoundProcedure> {
@@ -36,6 +36,12 @@ pub fn bind_statement(&mut self, statement: &Statement) -> BindResult<BoundState
                 .bind_composite_query_statement(statement)
                 .map(BoundStatement::Query),
             Statement::Data(_) => not_implemented("data-modifying statement".to_string(), None),
+            Statement::Explain(explain) => {
+                let bound_statement = self.bind_statement(&explain.statement.value())?;
+                Ok(BoundStatement::Explain(Box::new(BoundExplainStatement {
+                    statement: Box::new(bound_statement),
+                })))
+            }
         }
     }
 }
diff --git a/minigu/gql/planner/src/bound/procedure_spec.rs b/minigu/gql/planner/src/bound/procedure_spec.rs
index 95584fa..2e9ebc9 100644
--- a/minigu/gql/planner/src/bound/procedure_spec.rs
+++ b/minigu/gql/planner/src/bound/procedure_spec.rs
@@ -16,10 +16,16 @@ pub fn schema(&self) -> Option<DataSchemaRef> {
     }
 }
 
+#[derive(Debug, Clone, Serialize)]
+pub struct BoundExplainStatement {
+    pub statement: Box<BoundStatement>,
+}
+
 #[derive(Debug, Clone, Serialize)]
 pub enum BoundStatement {
     Catalog(Vec<BoundCatalogModifyingStatement>),
     Query(BoundCompositeQueryStatement),
+    Explain(Box<BoundExplainStatement>),
     // Data(BoundLinearDataModifyingStatement),
 }
 
diff --git a/minigu/gql/planner/src/lib.rs b/minigu/gql/planner/src/lib.rs
index 2cb9042..836bce0 100644
--- a/minigu/gql/planner/src/lib.rs
+++ b/minigu/gql/planner/src/lib.rs
@@ -23,7 +23,7 @@ pub fn new(context: SessionContext) -> Self {
         Self { context }
     }
 
-    pub fn plan_query(&self, query: &Procedure) -> PlanResult<PlanNode> {
+    pub fn plan_query(&self, query: &Procedure, is_explain: bool) -> PlanResult<PlanNode> {
         let binder = Binder::new(
             self.context.database().catalog(),
             self.context.current_schema.clone().map(|s| s as _),
@@ -33,6 +33,9 @@ pub fn plan_query(&self, query: &Procedure) -> PlanResult<PlanNode> {
         );
         let bound = binder.bind(query)?;
         let logical_plan = LogicalPlanner::new().create_logical_plan(bound)?;
+        if is_explain {
+            return Ok(logical_plan);
+        }
         Optimizer::new().create_physical_plan(&logical_plan)
     }
 }
diff --git a/minigu/gql/planner/src/logical_planner/procedure_spec.rs b/minigu/gql/planner/src/logical_planner/procedure_spec.rs
index 3866046..3d2e8b8 100644
--- a/minigu/gql/planner/src/logical_planner/procedure_spec.rs
+++ b/minigu/gql/planner/src/logical_planner/procedure_spec.rs
@@ -27,6 +27,10 @@ pub fn plan_statement(&self, statement: BoundStatement) -> PlanResult<PlanNode>
                 self.plan_catalog_modifying_statement(statement)
             }
             BoundStatement::Query(statement) => self.plan_composite_query_statement(statement),
+            BoundStatement::Explain(explain) => {
+                let plan = self.plan_statement(*explain.statement)?;
+                Ok(plan)
+            }
         }
     }
 }
-- 
2.34.1

